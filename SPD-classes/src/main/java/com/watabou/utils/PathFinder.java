/* * Pixel Dungeon * Copyright (C) 2012-2015  Oleg Dolya * * Shattered Pixel Dungeon * Copyright (C) 2014-2016 Evan Debenham * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see <http://www.gnu.org/licenses/> */package com.watabou.utils;import java.util.Arrays;import java.util.LinkedList;public class PathFinder {    public static int[] distance;    private static int[] maxVal;    private static boolean[] goals;    private static int[] queue;    private static int size = 0;    private static int width = 0;    private static int[] dir;    private static int[] dirLR;    //performance-light shortcuts for some common pathfinder cases    //they are in array-access order for increased memory performance    public static int[] NEIGHBOURS4;    public static int[] NEIGHBOURS8;    public static int[] NEIGHBOURS9;    public static int[] NEIGHBOURS24;    public static int[]CUSTOMCONE;//Add this to handle handconnon and to come shotgun in a easier and simple way   //similar to their equivalent neighbour arrays, but the order is clockwise.    //Useful for some logic functions, but is slower due to lack of array-access order.    public static int[] CIRCLE4;    public static int[] CIRCLE8;    public static void setMapSize( int width, int height ) {        PathFinder.width = width;        PathFinder.size = width * height;        distance = new int[size];        goals = new boolean[size];        queue = new int[size];        maxVal = new int[size];        Arrays.fill(maxVal, Integer.MAX_VALUE);        dir = new int[]{-1, +1, -width, +width, -width-1, -width+1, +width-1, +width+1};        dirLR = new int[]{-1-width, -1, -1+width, -width, +width, +1-width, +1, +1+width};        NEIGHBOURS4 = new int[]{-width, -1, +1, +width};        NEIGHBOURS8 = new int[]{-width-1, -width, -width+1, -1, +1, +width-1, +width, +width+1};        NEIGHBOURS9 = new int[]{-width-1, -width, -width+1, -1, 0, +1, +width-1, +width, +width+1};        NEIGHBOURS24= new int[]{-2*width+2,-2*width+1,-2*width,-2*width-1,-2*width-2,-width+2,-width+1,-width,-width-1,-width-2,+2,+1,-1,-2,width+2,width+1,width,width-1,width-2,2*width+2,2*width+1,2*width,2*width-1,2*width-2};        CIRCLE4 = new int[]{-width, +1, +width, -1};        CIRCLE8 = new int[]{-width-1, -width, -width+1, +1, +width+1, +width, +width-1, -1};        CUSTOMCONE = new int[]{//note that the most far block would contain the block next to hero when use ballistica                -width-3 , -width-2 , -2*width-2 , -2*width-1 , -3*width-1,                -width-1 , -width+1 , -2*width-1, -2*width , -2*width+1,                -width+2 , -width+3 , -2*width+1 , -2*width+2 , -3*width+1,                -width-2 , -width-1 , -2 , +width-2 , +width-1,                -width+1 , -width+2 , +2 , +width+1 , +width+2,                +width-3 , +width-2 , +2*width-2 , +2*width-1 , +3*width-1,                +width-1 , +width+1 , +2*width-1, +2*width , +2*width+1,                +width+2 , +width+3 , +2*width+1 , +2*width+2 , +3*width+1,        };    }    public int geticepos(int from,int to,boolean[] passable,boolean[] ice)    {        if(ice[to])        {            int newpos = to + (to - from);            return geticepos( to,newpos,passable,ice);        }        else return to;    }    public static Path find( int from, int to, boolean[] passable ,boolean[] ice) {        if (!buildDistanceMap( from, to, passable , ice)) {            return null;        }        Path result = new Path();        int s = from;        // From the starting position we are moving downwards,        // until we reach the ending point        do {            int minD = distance[s];            int mins = s;            for (int i=0; i < dir.length; i++) {                int n = s + dir[i];                while(n>0 && n < size && ice[n])                {                    int newpos = n + (n - s);                    if(newpos < size && passable[newpos]) { n = newpos ; }                    else break;                }                int thisD = distance[n];                if (thisD < minD) {                    minD = thisD;                    mins = n;                }            }            s = mins;            result.add( s );        } while (s != to);        return result;    }    public static int getStep( int from, int to, boolean[] passable , boolean[] ice) {        if (!buildDistanceMap( from, to, passable ,ice)) {            return -1;        }        // From the starting position we are making one step downwards        int minD = distance[from];        int best = from;        int step, stepD;        for (int i=0; i < dir.length; i++) {            if ((stepD = distance[step = from + dir[i]]) < minD) {                minD = stepD;                best = step;            }        }        return best;    }    public static int getStepBack( int cur, int from, boolean[] passable ) {        int d = buildEscapeDistanceMap( cur, from, 2f, passable );        for (int i=0; i < size; i++) {            goals[i] = distance[i] == d;        }        if (!buildDistanceMap( cur, goals, passable )) {            return -1;        }        int s = cur;        // From the starting position we are making one step downwards        int minD = distance[s];        int mins = s;        for (int i=0; i < dir.length; i++) {            int n = s + dir[i];            int thisD = distance[n];            if (thisD < minD) {                minD = thisD;                mins = n;            }        }        return mins;    }    //FIXME After adding ice floor,mobs' auto-path-finding becomes stupid,as the ice change the rule of distance,I'm trying to fix it but can't count too much on it    private static boolean buildDistanceMap( int from, int to, boolean[] passable ,boolean[] ice) {        if (from == to) {            return false;        }        System.arraycopy(maxVal, 0, distance, 0, maxVal.length);        boolean pathFound = false;        int head = 0;        int tail = 0;        // Add to queue        queue[tail++] = to;        distance[to] = 0;        while (head < tail) {            // Remove from queue            int step = queue[head++];            if (step == from) {                pathFound = true;                break;            }            int nextDistance = distance[step] + 1;            int start = (step % width == 0 ? 3 : 0);//if this pos happen to place on the left side,then can not add former 3(no -1)            int end   = ((step+1) % width == 0 ? 3 : 0);//similar,but on the right side(no +1)            for (int i = start; i < dirLR.length - end; i++) {                int n = step + dirLR[i];                while(n>0 && n < size && ice[n])//get the stop pos as the dst way,however it may not be able to review                {                    int newpos = step + (step - n);                    if( newpos > 0 && newpos < size && passable[newpos]) { n = newpos ; }                    else break;                }                if (n == from || (n >= 0 && n < size && passable[n] && (distance[n] > nextDistance))) {                    // Add to queue                    queue[tail++] = n;                    distance[n] = nextDistance;                }            }        }        return pathFound;    }    public static void buildDistanceMap( int to, boolean[] passable, int limit ) {        System.arraycopy(maxVal, 0, distance, 0, maxVal.length);        int head = 0;        int tail = 0;        // Add to queue        queue[tail++] = to;        distance[to] = 0;        while (head < tail) {            // Remove from queue            int step = queue[head++];            int nextDistance = distance[step] + 1;            if (nextDistance > limit) {                return;            }            int start = (step % width == 0 ? 3 : 0);            int end   = ((step+1) % width == 0 ? 3 : 0);            for (int i = start; i < dirLR.length - end; i++) {                int n = step + dirLR[i];                if (n >= 0 && n < size && passable[n] && (distance[n] > nextDistance)) {                    // Add to queue                    queue[tail++] = n;                    distance[n] = nextDistance;                }            }        }    }    private static boolean buildDistanceMap( int from, boolean[] to, boolean[] passable ) {        if (to[from]) {            return false;        }        System.arraycopy(maxVal, 0, distance, 0, maxVal.length);        boolean pathFound = false;        int head = 0;        int tail = 0;        // Add to queue        for (int i=0; i < size; i++) {            if (to[i]) {                queue[tail++] = i;                distance[i] = 0;            }        }        while (head < tail) {            // Remove from queue            int step = queue[head++];            if (step == from) {                pathFound = true;                break;            }            int nextDistance = distance[step] + 1;            int start = (step % width == 0 ? 3 : 0);            int end   = ((step+1) % width == 0 ? 3 : 0);            for (int i = start; i < dirLR.length - end; i++) {                int n = step + dirLR[i];                if (n == from || (n >= 0 && n < size && passable[n] && (distance[n] > nextDistance))) {                    // Add to queue                    queue[tail++] = n;                    distance[n] = nextDistance;                }            }        }        return pathFound;    }    private static int buildEscapeDistanceMap( int cur, int from, float factor, boolean[] passable ) {        System.arraycopy(maxVal, 0, distance, 0, maxVal.length);        int destDist = Integer.MAX_VALUE;        int head = 0;        int tail = 0;        // Add to queue        queue[tail++] = from;        distance[from] = 0;        int dist = 0;        while (head < tail) {            // Remove from queue            int step = queue[head++];            dist = distance[step];            if (dist > destDist) {                return destDist;            }            if (step == cur) {                destDist = (int)(dist * factor) + 1;            }            int nextDistance = dist + 1;            int start = (step % width == 0 ? 3 : 0);            int end   = ((step+1) % width == 0 ? 3 : 0);            for (int i = start; i < dirLR.length - end; i++) {                int n = step + dirLR[i];                if (n >= 0 && n < size && passable[n] && distance[n] > nextDistance) {                    // Add to queue                    queue[tail++] = n;                    distance[n] = nextDistance;                }            }        }        return dist;    }    public static void buildDistanceMap( int to, boolean[] passable ) {        System.arraycopy(maxVal, 0, distance, 0, maxVal.length);        int head = 0;        int tail = 0;        // Add to queue        queue[tail++] = to;        distance[to] = 0;        while (head < tail) {            // Remove from queue            int step = queue[head++];            int nextDistance = distance[step] + 1;            int start = (step % width == 0 ? 3 : 0);            int end   = ((step+1) % width == 0 ? 3 : 0);            for (int i = start; i < dirLR.length - end; i++) {                int n = step + dirLR[i];                if (n >= 0 && n < size && passable[n] && (distance[n] > nextDistance)) {                    // Add to queue                    queue[tail++] = n;                    distance[n] = nextDistance;                }            }        }    }    @SuppressWarnings("serial")    public static class Path extends LinkedList<Integer> {    }}